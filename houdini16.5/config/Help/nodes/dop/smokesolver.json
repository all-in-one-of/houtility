{"body": [{"indent": 0, "text": ["Smoke Solver"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Sets and configures a Smoke solver. This is a slightly lower-level solver that is the basis for the Pyro solver."]}, {"indent": 0, "type": "para", "text": ["See ", {"text": ["Pyro look development"], "fullpath": "/pyro/pyro_look", "scheme": null, "type": "link", "value": "/pyro/pyro_look"}, " for information on using the parameters to achieve different flame and smoke looks."]}, {"indent": 0, "type": "para", "text": ["The smoke solver provides the basics of smoke simulation, whereas the ", {"text": ["Pyro Solver"], "fullpath": "/nodes/dop/pyrosolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/pyrosolver"}, " adds flame simulation and extra shaping controls. If you just want to generate smoke, the smoke solver is useful since it is simpler and expert users can build their own extensions on it. However, the ", {"text": ["Pyro Solver"], "fullpath": "/nodes/dop/pyrosolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/pyrosolver"}, " is more flexible."]}, {"indent": 0, "type": "para", "text": ["See ", {"text": ["how to use the Pyro tools"], "fullpath": "/pyro/pyro", "scheme": null, "type": "link", "value": "/pyro/pyro"}, " for information on creating simulations using the shelf tools."]}, {"body": [{"indent": 0, "type": "para", "text": ["If you ", {"text": ["use the shelf tools"], "fullpath": "/pyro/pyro", "scheme": null, "type": "link", "value": "/pyro/pyro"}, " to create Pyro effects, they will set up the sourcing, solver, and output object for you automatically."]}, {"indent": 0, "type": "para", "text": ["If you are setting up a pyro network from scratch, you can use the ", {"text": ["Smoke Object node"], "fullpath": "/nodes/dop/smokeobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/smokeobject"}, " to create a DOP object with the data required by the Pyro solver already attached. If you already have a DOP object, you can use the the ", {"text": ["Smoke Configure Object node"], "fullpath": "/nodes/dop/smokeconfigureobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/smokeconfigureobject"}, " to add the necessary data to it."]}, {"indent": 0, "type": "para", "text": ["This solver makes use of various field subdata on the object."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": ["The object should have a scalar field ", {"text": ["density"], "type": "code"}, " for the density of the smoke."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["The object should have a vector field ", {"text": ["vel"], "type": "code"}, " for the velocity at each voxel."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Optionally, the object can have a scalar field ", {"text": ["temperature"], "type": "code"}, " for internal buoyancy calculations."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Setting up"], "container": true, "type": "h", "id": "setup"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["A ", {"text": ["Smoke object"], "fullpath": "/nodes/dop/smokeobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/smokeobject"}, " to work on. Note that a smoke\n    object can contain multiple containers."]}], "indent": 0, "type": "dt", "attrs": {"id": "object_input"}, "text": ["Object"]}, {"body": [{"indent": 4, "type": "para", "text": ["Run the network branch attached to this input before each solving\n    step. In the standard ", {"text": ["pyro setup"], "fullpath": "/pyro/pyro", "scheme": null, "type": "link", "value": "/pyro/pyro"}, ", the attached node (", {"text": ["Gas Resize Fluid Dynamic"], "fullpath": "/nodes/dop/gasresizefluiddynamic", "scheme": "Node", "type": "link", "value": "/nodes/dop/gasresizefluiddynamic"}, ") automatically resizes the fluid containers at each step."]}], "indent": 0, "type": "dt", "attrs": {"id": "presolve_input"}, "text": ["Pre-solve"]}, {"body": [{"indent": 4, "type": "para", "text": ["Nodes attached to this input can edit the simulation network\u2019s velocity fields, for example to apply custom forces, ", {"text": ["before"], "type": "em"}, " the \"project gas non-divergent\" step (see also the \"Sourcing (post-solve)\" input below)."]}], "indent": 0, "type": "dt", "attrs": {"id": "velupdate_input"}, "text": ["Velocity update"]}, {"body": [{"indent": 4, "type": "para", "text": ["Connect a ", {"text": ["Gas Advect node"], "fullpath": "/nodes/dop/gasadvect", "scheme": "Node", "type": "link", "value": "/nodes/dop/gasadvect"}, " to this input to allow the it to advect the points of geometry data attached to the container based on the fields in this solver."]}], "indent": 0, "type": "dt", "attrs": {"id": "advection_input"}, "text": ["Advection"]}, {"body": [{"indent": 4, "type": "para", "text": ["The main use for this input is to add volumes attached to this input as fuel sources, density sources, sinks, collision fields, pumps, etc. These volumes will usually be created by a ", {"text": ["Source Volume node"], "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link", "value": "/nodes/dop/sourcevolume"}, " that imports volumes from a geometry network. See ", {"text": ["pyro sourcing"], "fullpath": "/dyno/fluid_sourcing", "scheme": null, "type": "link", "value": "/dyno/fluid_sourcing"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Nodes attached to this input can also edit the simulation network\u2019s velocity fields, for example to apply custom forces, ", {"text": ["after"], "type": "em"}, " the \"project gas non-divergent\" step."]}], "indent": 0, "type": "dt", "attrs": {"id": "sourcing_input"}, "text": ["Sourcing (post-solve)"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"indent": 0, "type": "para", "text": ["These parameters control how the simulation develops over time. See ", {"text": ["how pyro simulations work"], "fullpath": "/pyro/pyro", "scheme": null, "type": "link", "value": "/pyro/pyro"}, " for information on how the temperature and velocity fields drive the simulation to a great extent."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["A scaling factor for time inside this solver. ", {"text": ["1"], "type": "code"}, " is normal speed, greater than ", {"text": ["1"], "type": "code"}, " makes the pyro sim appear speeded up, less than ", {"text": ["1"], "type": "code"}, " makes the pyro sim appear to be in slow motion."]}, {"indent": 4, "type": "para", "text": ["You can use expression functions such as ", {"text": "", "value": "/expressions/doptime", "fallback_text": "doptime()", "fullpath": "/expressions/doptime", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/dopframe", "fallback_text": "dopframe()", "fullpath": "/expressions/dopframe", "scheme": "Exp", "type": "link"}, ",", {"text": "", "value": "/expressions/dopsttot", "fallback_text": "dopsttot()", "fullpath": "/expressions/dopsttot", "scheme": "Exp", "type": "link"}, ", and ", {"text": "", "value": "/expressions/dopttost", "fallback_text": "dopttost()", "fullpath": "/expressions/dopttost", "scheme": "Exp", "type": "link"}, " to convert between global times and simulation times."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Changing the ", {"text": ["Timescale"], "type": "ui"}, " only affects the timestep of the simulation. If adding velocities calculated in SOPs to the simulation for collisions or pumps with the ", {"text": ["Source Volume DOP"], "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link", "value": "/nodes/dop/sourcevolume"}, ", scale the incoming velocities by ", {"text": ["1 / Timescale"], "type": "code"}, " to match the timestep of the simulation."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "text": ["Timescale"], "role": "item", "attrs": {"id": "timescale"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A Gaussian blur factor on the temperature field. Higher values spread the temperature out more and create a less sharply defined effect and more cooling. For example, a value of ", {"text": ["2 "], "type": "code"}, "will blur the temperature field by a radius of 2 every second."]}, {"indent": 4, "type": "para", "text": ["(The real-world motivation for this parameter is to simulate turbulence at a finer scale than the sim\u2019s resolution, which spreads the field out.)"]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Temperature Diffusion"]}, {"body": [{"indent": 4, "type": "para", "text": ["How fast the temperature field cools to zero. A value of 0.9 will decrease\n    the temperature of hot gas by 90% (to 10% of its original value) every\n    second."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["This is the inverse of the ", {"text": ["Cooling Rate"], "type": "ui"}, " parameter in Houdini 11 and lower versions."]}], "indent": 4, "role": "item", "type": "warning"}], "container": true, "role": "item_group", "type": "warning_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Cooling Rate"]}, {"body": [{"indent": 4, "type": "para", "text": ["The \"fluid-ness\" of the velocity field. Higher values make neighboring voxels have the same velocity, creating a more flowing look. A value of ", {"text": ["0"], "type": "code"}, " allows adjacent voxels to move any direction without resistance, creating a more chaotic, turbulent look."]}, {"indent": 4, "type": "para", "text": ["(Inside the solver, higher viscosity values introduce a penalty when a voxel\u2019s velocity varies from that of its neighbors. This is currently implemented by applying a diffusive term to the velocity field.)"]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Viscosity"]}, {"body": [{"indent": 4, "type": "para", "text": ["An upward force at each voxel scaled by the difference between the ambient temperature and voxel\u2019s temperature, so hotter areas will get more lift and cooler areas will sink. Increasing this makes the effect rise faster and go higher."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Buoyancy Lift"]}, {"body": [{"indent": 4, "type": "para", "text": ["The direction in which buoyancy is applied.  This is usually the Up direction of your simulation, but often can be altered to quickly tweak the look of a sim."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Buoyancy Dir"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Simulation"], "container": true, "type": "h", "id": "simtab"}, {"body": [{"indent": 0, "type": "para", "text": ["Prior to Houdini 12, the Pyro solver used DOP relationships to associate sources, pumps, sinks, and collision geometry with a fluid container, using the ", {"text": ["Merge DOP"], "fullpath": "/nodes/dop/merge", "scheme": "Node", "type": "link", "value": "/nodes/dop/merge"}, " and/or ", {"text": ["Apply relationship DOP"], "fullpath": "/nodes/dop/applyrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/applyrel"}, " to create the relationship. The preferred method in Houdini 12 and later is to ", {"text": ["use SOP networks to create sources, pumps, sinks, and collision geometry"], "fullpath": "/dyno/fluid_sourcing", "scheme": null, "type": "link", "value": "/dyno/fluid_sourcing"}, " and import them using the ", {"text": ["Source volume DOP"], "fullpath": "/nodes/dop/sourcevolume", "scheme": "Node", "type": "link", "value": "/nodes/dop/sourcevolume"}, "."]}, {"indent": 0, "type": "para", "text": ["If you want to use the old relationship method to set up sources, sinks, etc., you can enable relationships using the parameters on this tab. By default, relationships are turned off, and the solver ignores relationship data."]}, {"indent": 0, "type": "para", "text": ["You can use both methods (import SOP geometry and attach it to the solver\u2019s \"sourcing\" input, as well as set up DOP object relationships). When relationships are enabled, the solver will combine the sources, sinks, etc. from both methods."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use object relationship data to add sources, pumps, sinks, and collision geometry to the simulation (in addition to imported data connected to the sourcing input, if any)."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Relationships"]}], "container": true, "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["When using a source relationship, make sure the source object is emitting temperature. You can set this up on the object\u2019s physical properties tab."]}], "indent": 0, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use DOP objects with a \"source\" relationship to the solver."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Source Relationship"]}, {"body": [{"indent": 8, "type": "para", "text": ["The field to add the source to. The default is ", {"text": ["density"], "type": "code"}, ", which will create smoke. To create flame, you could change this to ", {"text": ["fuel"], "type": "code"}, " and set the temperature physical property of the source object."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Add Source To"]}, {"body": [{"indent": 8, "type": "para", "text": ["How the source object\u2019s volume will be added to the simulation.\n        Scale controls the addition amount."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Source Merge"]}, {"body": [{"indent": 4, "type": "para", "text": ["How the source object\u2019s velocity will affect the\n    container\u2019s velocity field. Scale controls the amount to add.   "]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Merge"]}, {"body": [{"indent": 4, "type": "para", "text": ["How the source object\u2019s temperature physical\n    parameter will affect the container\u2019s temperature field. Scale controls the amount of temperature to add."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Temperature Merge"]}, {"body": [{"indent": 4, "type": "para", "text": ["How to measure velocity on the source object. If the source geometry does not deform (change shape) over time, use \"Rigid velocity\". If the source deforms but does not change topology over time, use \"Point velocity\"."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Treat the source object as non-deforming."]}], "indent": 4, "type": "dt", "text": ["Rigid Velocity"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use point history to allow deforming geometry. This only\n        works if the topology of the source geometry doesn\u2019t change."]}], "indent": 4, "type": "dt", "text": ["Point Velocity"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use the SDF representation of the object. Allows deforming geometry and does not require a fixed topology over time, but cannot detect tangential velocities."]}], "indent": 4, "type": "dt", "text": ["Volume Velocity"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Velocity Type"], "role": "item", "attrs": {"id": "veltype"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Sources"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use DOP objects with a \"pump\" relationship to the solver."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Pump Relationship"]}, {"body": [{"indent": 4, "type": "para", "text": ["How the source object\u2019s velocity will affect the\n    container\u2019s velocity field. Scale controls the amount of velocity to add."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Velocity Merge"]}, {"body": [], "indent": 0, "text": ["Velocity Type"], "role": "item", "attrs": {"id": "pumpveltype", "contentfromt": "#veltype"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Whether the object\u2019s temperature property affects the temperature field of the container. If you choose \"Set interior\", the part of the temperature field corresponding to the inside the object will be set to the object\u2019s temperature."]}], "indent": 0, "text": ["Temperature Merge"], "role": "item", "attrs": {"id": "pumptemperaturemerge"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Pumps"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use DOP objects with a \"collision\" relationship to the solver."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Collide Relationship"]}, {"body": [{"indent": 4, "type": "para", "text": ["Whether the object\u2019s temperature property affects the temperature field of the container. If you choose \"Collision interior\", the part of the temperature field corresponding to the inside the object will be set to the object\u2019s temperature."]}], "indent": 0, "text": ["Temperature Merge"], "role": "item", "attrs": {"id": "collisiontemperaturemerge"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Normally the collision mask SDF is only calculated up to a certain distance from the original collision geometry. Turn this off to compute the full range of the mask if you need it for some special effect, such as having things react before they reach the object."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Restrict Mask to Bandwidth"]}, {"body": [{"indent": 4, "type": "para", "text": ["Turn this on if the collision geometry is deforming (changing shape) over time, but has consistent topology (e.g. number of points). If the topology changes over time, turn on ", {"text": ["Use volume velocity for collisions"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Point Velocity for Collisions"]}, {"body": [{"indent": 4, "type": "para", "text": ["Turn this on if the collision geometry is deforming (changing shape) and topology (e.g. number of points) over time."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Volume Velocity for Collisions"]}, {"body": [{"indent": 4, "type": "para", "text": ["Allows the fluid to collide with objects that don\u2019t have\n    Geometry/SDF, such as other fluids."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collide with Non-SDF"]}, {"body": [{"indent": 4, "type": "para", "text": ["Copies the density and fuel fields into the collision field. This causes the smoke to become \"sticky\" to avoid an air gap between the smoke and the collision field. This also prevents smoke from passing through moving collision fields."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Extrapolate into Collisions"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Collisions"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use DOP objects with a \"sink\" relationship to the solver."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Sink Relationship"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Sink"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Relationships"], "container": true, "type": "h", "id": "relationships"}, {"body": [{"indent": 0, "type": "para", "text": ["You should generally not need to change these parameters."]}, {"body": [{"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["Caching is enabled by default in DOPs."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["Resizing is enabled by default. Resizing has to go through the CPU to manage the field changes. It can also fragment the GPU memory resulting in out-of-memory errors."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": ["Use OpenCL"], "role": "item", "attrs": {"id": "opencl"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Forces the solver to run a minimum number of substeps. Normally the pyro solver works best with no substeps. If you have smoke and unusual forces you may want to increase this parameter for better stability. Increasing this will usually make the simulation much slower."]}], "indent": 0, "text": ["Min Substeps"], "role": "item", "attrs": {"id": "minimumsubsteps"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Forces the solver to not run more substeps than this maximum. Normally the pyro solver works best with no substeps. If you have smoke and unusual forces you may want to increase this parameter for better stability. Increasing this will usually make the simulation much slower."]}], "indent": 0, "text": ["Max Substeps"], "role": "item", "attrs": {"id": "substeps"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["When ", {"text": ["Max Substeps"], "type": "ui"}, " is greater than ", {"text": ["1"], "type": "code"}, ", the solver uses this parameter to decide the number of substeps. The \"condition\" is that no substep can allow objects to interpenetrate by more than this many voxels. Higher values allow a substep to move smoke by more voxels, possibly letting it pass through collision objects."]}], "indent": 0, "text": ["CFL Condition"], "role": "item", "attrs": {"id": "cflcond"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Alway use substeps that divide up the frame by ", {"text": ["Max Substeps"], "type": "ui"}, ".  For example,\n    if ", {"text": ["Max Substeps"], "type": "ui"}, " is set to 4, but the ", {"text": ["CFL Condition"], "type": "ui"}, " only requires 3 substeps,\n    the solver will take frame steps of 0.25, 0.5, and 0.25.  This option can be useful for\n    re-using input geometry that has been cached to file at increments of 1/", {"text": ["Max Substeps"], "type": "ui"}, "."]}], "indent": 0, "text": ["Quantize to Max Substeps"], "role": "item", "attrs": {"id": "quantize"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Delays the actual simulation this many frames after the object creation.\n    Sourcing will still occur in these frames.  This may be needed if\n    some solve nodes can\u2019t be processed before certain initial conditions\n    have been met."]}], "indent": 0, "text": ["Frames Before Solve"], "role": "item", "attrs": {"id": "frames_before_solve"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["A list of forces to scale by the value of the ", {"text": ["forcescale"], "type": "code"}, " field at each voxel. The default is all forces except gravity."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Scaled Forces"]}, {"body": [{"indent": 4, "type": "para", "text": ["A list of forces to apply uniformly to all voxels, ignoring the ", {"text": ["forcescale"], "type": "code"}, " field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Absolute Forces"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["External Forces"], "container": true, "type": "h", "id": "adv_externaltab"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Creates rest fields, which can be used to track the position of the fluid over time. Turn this on to correctly map noise or textures in the volume shader."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Enable Rest"]}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a ", {"text": ["rest2"], "type": "code"}, " field that is one back from the the main ", {"text": ["rest"], "type": "code"}, " field, allowing you to run long simulations without popping."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Dual Rest Fields"]}, {"body": [{"indent": 4, "type": "para", "text": ["Number of frames before resetting the rest field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Frames Between Solve"]}, {"body": [{"indent": 4, "type": "para", "text": ["Which frame the rest field will be reset on. If you are prerolling the simulation, delaying the rest field initialization until after the preroll will usually give a better result."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Frame Offset"]}, {"body": [{"indent": 4, "type": "para", "text": ["How fast the rest field moves in response to the velocity field. A value of ", {"text": ["1"], "type": "code"}, " would make the rest field match the fluid exactly, however that would quickly smear the rest field out in streaks. Values lower than ", {"text": ["1"], "type": "code"}, " move the rest field slower than the actual fluid, decreasing streaking."]}], "indent": 0, "text": ["Time Scale"], "role": "item", "attrs": {"id": "timescale"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Rest Field"], "container": true, "type": "h", "id": "adv_restfieldtab"}, {"body": [{"indent": 0, "type": "para", "text": ["The \"project non-divergent\" step of the simulation removes the divergence components in the velocity field."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The project non-divergence algorithm. \"PCG\" has more accurate boundary conditions and avoids computation inside collision objects. Multigrid is significantly faster, especially on large or high resolution containers."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Projection Method"]}, {"body": [{"indent": 4, "type": "para", "text": ["The multigrid project non-divergence method has inaccurate boundary enforcement. You can increase this number to run the enforcement/projection multiple times, making it more accurate. You should not have to set this higher than ", {"text": ["5"], "type": "code"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Multigrid Iterations"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Projection"], "container": true, "type": "h", "id": "adv_projectiontab"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The algorithm to use for advecting the fields."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Equivalent to the ", {"text": ["Gas Advect DOP"], "fullpath": "/nodes/dop/gasadvect", "scheme": "Node", "type": "link", "value": "/nodes/dop/gasadvect"}, ", where each point is back traced through the velocity field once to find the new voxel value."]}], "indent": 4, "type": "dt", "text": ["Single stage"]}, {"body": [{"indent": 8, "type": "para", "text": ["Run a second basic advection stage, resulting in a sharper fluid that doesn\u2019t disperse as much."]}], "indent": 4, "type": "dt", "text": ["BFECC and Modified MacCormack"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Advection Type"]}, {"body": [{"indent": 4, "type": "para", "text": ["The error correction of the BFECC and Modified MacCormack advection types can move voxel values outside the container, leading to strange effects such as negative density values. This parameter lets you choose a method to avoid this problem. The default is \"Revert\"."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Do not attempt to prevent error correction from moving values outside the container."]}], "indent": 4, "type": "dt", "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "text": ["Restrict each voxel to the range of values possible given its eight original values."]}], "indent": 4, "type": "dt", "text": ["Clamp"]}, {"body": [{"indent": 8, "type": "para", "text": ["If the error-corrected voxel is out of range, return it to the single-stage value."]}], "indent": 4, "type": "dt", "text": ["Revert"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Reverting can avoid checker artifacts where the error correction breaks down."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Clamp Values"]}, {"body": [{"indent": 4, "type": "para", "text": ["Apply a smooth blend between non-clamped and clamped values as the advected field\n    approaches the clamping limit. Particularly with the ", {"text": ["Revert"], "type": "ui"}, " option, applying a small\n    amount of ", {"text": ["Blend"], "type": "ui"}, " (e.g. 0.05 - 0.1) can reduce grid artifacts in the advected field\n    at the cost of some additional smoothing of the field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Blend"]}, {"body": [{"indent": 4, "type": "para", "text": ["The algorithm to use for advecting the velocity field. Higher types in the list will reduce the apparent viscosity of the field, but may add energy or cause chatter."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Vel Advection Type"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls particle tracing."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Takes the velocity at each voxel and makes a single step in\n        that direction for the time step. This is fastest and is\n        independent of the speed of the velocity field, but will start\n        to break up for large time steps."]}], "indent": 4, "type": "dt", "text": ["Single step"]}, {"body": [{"indent": 8, "type": "para", "text": ["Ensures the backtracking does not move more than a single\n        voxel before its velocity is updated, allowing for larger\n        time steps."]}], "indent": 4, "type": "dt", "text": ["Trace"]}, {"body": [{"indent": 8, "type": "para", "text": ["Like ", {"text": ["Trace"], "type": "ui"}, " but uses second order advection for more accuracy\n        but slower simulation."]}], "indent": 4, "type": "dt", "text": ["Trace Midpoint"]}, {"body": [{"indent": 8, "type": "para", "text": ["A non-lagrangian integrator, this allows for theoretically more\n        accurate advection of divergent fields.  Unfortunately, if too large\n        substeps are taken, it will explode."]}], "indent": 4, "type": "dt", "text": ["HJWENO"]}, {"body": [{"indent": 8, "type": "para", "text": ["A faster but less accurate non-lagrangian integrator."]}], "indent": 4, "type": "dt", "text": ["Upwind"]}, {"body": [{"indent": 8, "type": "para", "text": ["Like ", {"text": ["Trace"], "type": "ui"}, " but uses third order advection for more accuracy\n        but slower simulation."]}], "indent": 4, "type": "dt", "text": ["Trace RK3"]}, {"body": [{"indent": 8, "type": "para", "text": ["Like ", {"text": ["Trace"], "type": "ui"}, " but uses fourth order advection for more accuracy\n        but slower simulation."]}], "indent": 4, "type": "dt", "text": ["Trace RK4"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Advection Method"]}, {"body": [{"indent": 4, "type": "para", "text": ["When tracing the particles, this controls how many voxels the particles can move in a single iterations. Higher values give faster tracing and faster advection, but more errors."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Advection CFL"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Advection"], "container": true, "type": "h", "id": "adv_advectiontab"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Sets density and fuel fields to ", {"text": ["0"], "type": "code"}, " inside collision objects. This helps prevent fuel and density from leaking through moving objects."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Correct Collisions"]}, {"body": [{"indent": 4, "type": "para", "text": ["A scale factor for applying feedback forces to other objects. Setting this to ", {"text": ["0"], "type": "code"}, " will prevent any feedback."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Feedback Scale"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Collisions"], "container": true, "type": "h", "id": "adv_collisionstab"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Zeros out the specified types of fields after the solve step. This ensures the ", {"text": [".sim"], "type": "code"}, " files, which store the complete state of the simulation, do not have extra information, reducing their size and saving time."]}, {"body": [{"body": [{"indent": 12, "type": "para", "text": ["Do not clear fields."]}], "indent": 4, "type": "dt", "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "text": ["Clear fields not needed for the next time step that do not have guide parameters."]}], "indent": 4, "type": "dt", "text": ["Hidden"]}, {"body": [{"indent": 8, "type": "para", "text": ["Clear fields not needed for next time step. Some of these fields will have guides and the guides will start showing zero values since the underlying field was cleared."]}], "indent": 4, "type": "dt", "text": ["Static"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Fields to Clear"]}, {"body": [{"indent": 8, "type": "para", "text": ["A space separated list of fields to clear after each solve."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Additional"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Clear"], "container": true, "type": "h", "id": "adv_cleartab"}], "indent": 0, "level": 2, "text": ["Advanced"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["The operation of this output depends on what inputs are connected\n    to this node. If an object stream is input to this node, the output\n    is also an object stream containing the same objects as the input\n    (but with the data from this node attached). "]}, {"type": "para", "indent": 4, "text": ["If no object stream is\n    connected to this node, the output is a data output. This data\n    output can be connected to an ", {"text": ["Apply Data DOP"], "fullpath": "/nodes/dop/applydata", "scheme": "Node", "type": "link", "value": "/nodes/dop/applydata"}, ",\n    or connected directly to a data input of another data node, to\n    attach the data from this node to an object or another piece of\n    data."]}], "type": "dt", "indent": 0, "text": ["First Output"]}], "type": "dt_group", "container": true}], "indent": 0, "level": 1, "text": "Outputs", "role": "section", "container": true, "type": "outputs_section", "id": "outputs"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["This DOP node defines a local variable for each channel and\n    parameter on the Data Options page, with the same name as the\n    channel. So for example, the node may have channels for Position\n    (positionx, positiony, positionz) and a parameter for an object name\n    (objectname). "]}, {"type": "para", "indent": 4, "text": ["Then there will also be local variables with the names\n    positionx, positiony, positionz, and objectname. These variables\n    will evaluate to the previous value for that parameter. "]}, {"type": "para", "indent": 4, "text": ["This previous value is always stored as part of the data attached to the\n    object being processed. This is essentially a shortcut for a\n    dopfield expression like:"]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    dopfield($DOPNET, $OBJID, dataName, \"Options\", 0, channelname)\n    "]}, {"type": "para", "indent": 4, "text": ["If the data does not already exist, then a value of zero or an\n    empty string will be returned."]}], "type": "dt", "indent": 0, "text": ["channelname"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current data was created. This value may not be the same as the\n    current simulation time if this node is modifying existing data,\n    rather than creating new data."]}], "type": "dt", "indent": 0, "text": ["DATACT"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current data was created. This value may not be the same as the\n    current simulation frame if this node is modifying existing data,\n    rather than creating new data."]}], "type": "dt", "indent": 0, "text": ["DATACF"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to the\n    name of the relationship the data to which the data is being attached."]}], "type": "dt", "indent": 0, "text": ["RELNAME"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affected Objects of the relationship to which the data is being\n    attached."]}], "type": "dt", "indent": 0, "text": ["RELOBJIDS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affected\n    Objects of the relationship to which the data is being attached."]}], "type": "dt", "indent": 0, "text": ["RELOBJNAMES"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affector Objects of the relationship to which the data is being\n    attached."]}], "type": "dt", "indent": 0, "text": ["RELAFFOBJIDS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affector\n    Objects of the relationship to which the data is being attached."]}], "type": "dt", "indent": 0, "text": ["RELAFFOBJNAMES"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time for which the node is being\n    evaluated. "]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini time\n    represented by the variable T, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " ", {"text": ["Offset Time"], "type": "ui"}, " and ", {"text": ["Time Scale"], "type": "ui"}, "\n    parameters. "]}, {"type": "para", "indent": 4, "text": ["This value is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"text": ["$ST == 0"], "type": "code"}, " rather than\n    ", {"text": ["$T == 0"], "type": "code"}, " or ", {"text": ["$FF == 1"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "text": ["ST"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (or more accurately, the\n    simulation time step number) for which the node is being evaluated."]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini frame number\n    represented by the variable F, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " parameters. Instead, this value is equal to\n    the simulation time (ST) divided by the simulation timestep size\n    (TIMESTEP)."]}], "type": "dt", "indent": 0, "text": ["SF"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the size of a simulation timestep. This value is\n    useful to scale values that are expressed in units per second, but\n    are applied on each timestep."]}], "type": "dt", "indent": 0, "text": ["TIMESTEP"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."]}], "type": "dt", "indent": 0, "text": ["SFPS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is the number of objects in the simulation. For nodes that\n    create objects such as the ", {"text": ["Empty Object"], "fullpath": "/nodes/dop/emptyobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/emptyobject"}, " node,\n    this value will increase for each object that is evaluated. "]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"text": ["object_$SNOBJ"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "text": ["SNOBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the number of objects that will be evaluated by the\n    current node during this timestep. This value will often be\n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "]}, {"type": "para", "indent": 4, "text": ["This value may return 0 if the node does not\n    process each object sequentially (such as the ", {"text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["NOBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the index of the specific object being processed by\n    the node. This value will always run from zero to NOBJ-1 in a given\n    timestep. This value does not identify the current object within the\n    simulation like OBJID or OBJNAME, just the object\u2019s position in the\n    current order of processing. "]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    will be -1 if the node does not process objects sequentially (such\n    as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is the unique object identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. "]}, {"type": "para", "indent": 4, "text": ["The object identifier\n    can always be used to uniquely identify a given object. This makes\n    this variable very useful in situations where each object needs to\n    be treated differently. It can be used to produce a unique random\n    number for each object, for example. "]}, {"type": "para", "indent": 4, "text": ["This value is also the best way\n    to look up information on an object using the dopfield expression\n    function. This value will be -1 if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJID"]}, {"body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the unique object\n    identifiers for every object being processed by the current node."]}], "type": "dt", "indent": 0, "text": ["ALLOBJIDS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the names of every\n    object being processed by the current node."]}], "type": "dt", "indent": 0, "text": ["ALLOBJNAMES"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "text": ["Therefore, to check if an object was created\n    on the current timestep, the expression ", {"text": ["$ST == $OBJCT"], "type": "code"}, " should\n    always be used. This value will be zero if the node does not process\n    objects sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJCT"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "text": ["This value is equivalent to using the\n    dopsttoframe expression on the OBJCT variable. This value will be\n    zero if the node does not process objects sequentially (such as the\n    ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJCF"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the name of the object being\n    processed. "]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named \"myobject\",\n    specifying ", {"text": ["strcmp($OBJNAME, \"myobject\") == 0"], "type": "code"}, " in the activation field\n    of a DOP will cause that DOP to operate only on those 20 objects. This\n    value will be the empty string if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJNAME"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the full path of the current DOP\n    Network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP Network that contains the\n    node."]}], "type": "dt", "indent": 0, "text": ["DOPNET"]}], "type": "dt_group", "container": true}, {"body": [{"body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"text": ["Position node"], "fullpath": "/nodes/dop/position", "scheme": "Node", "type": "link", "value": "/nodes/dop/position"}, ",\n    you could write the expression:"]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."]}], "role": "item", "indent": 0, "type": "note"}], "role": "item_group", "container": true, "type": "note_group"}], "indent": 0, "level": 1, "text": "Locals", "role": "section", "container": true, "type": "locals_section", "id": "locals"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Pyro Effects"], "fullpath": "/pyro/pyro", "scheme": null, "type": "link", "value": "/pyro/pyro"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/dop/smokeobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/smokeobject"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/fluidsource", "scheme": "Node", "type": "link", "value": "/nodes/sop/fluidsource"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/dop/pyrosolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/pyrosolver"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "title": ["Smoke Solver"], "summary": ["Sets and configures a Smoke solver. This is a slightly lower-level solver that is the basis for the Pyro solver."], "attrs": {"version": "2.0", "namespace": null, "internal": "smokesolver::2.0", "context": "dop", "type": "node", "icon": "DOP/smokesolver"}, "included": ["/nodes/dop/old_relationships", "/nodes/dop/standard_locals", "/nodes/dop/standard_data_outputs", "/nodes/dop/standard_data_locals"], "type": "root"}