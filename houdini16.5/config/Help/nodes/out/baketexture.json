{"body": [{"indent": 0, "text": ["Bake Texture"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Generates a texture map from one or more objects' rendered appearance."]}, {"body": [{"indent": 0, "type": "para", "text": ["It can be useful to generate a texture from the rendered appearance of a model."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["This is especially useful when you ", {"fragment": "#xfer", "text": ["bake a texture from a high-resolution model and apply it to a low-resolution model"], "value": "#xfer", "fullpath": "/nodes/out/baketexture#xfer", "scheme": null, "type": "link"}, ", possibly in combination with other resolution \"tricks\" such as subdivision surfaces."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["As a performance \"cheat\", you can bake the fully rendered appearance of a model into a texture, and then use the texture instead of running the actual shaders. When you can get away with it (where it\u2019s not noticeable that the object\u2019s appearance doesn\u2019t change), this can give a large speedup, especially for large numbers of identical objects with complex shaders."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["You can capture the rendered appearance of a model as the starting point for a hand-painted texture map."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "text": ["This node renders one or more objects as flat texture maps."]}], "indent": 0, "level": 2, "text": ["Overview"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["This node can generate UDIM unwrapped texture images, or ", {"text": ["Ptex"], "fullpath": "/shade/ptex", "scheme": null, "type": "link", "value": "/shade/ptex"}, " texture maps, using the ", {"text": ["UV unwrapping method"], "type": "ui"}, " parameter."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["The node will replace the string ", {"text": ["%(UDIM)d"], "type": "code"}, " in the output filename with the UDIM index."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["For UDIM textures, the node will use the ", {"text": ["uv"], "type": "code"}, " attribute on the model to lay out the baked output."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Ptex"], "fullpath": "/shade/ptex", "scheme": null, "type": "link", "value": "/shade/ptex"}, " generates a separate texture for each face and saves all the textures and the model topology together in a single archive. Since Ptex texture tiles must map to quadrilaterals, Mantra assumes the geometry will render as a subdivision surface. This node creates Ptex tiles for each polygon using the subdivision rules (3 faces for a triangle, 1 for a quad, 5 for a pentagon, 6 for a hexagon, and so on)."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["UDIM and Ptex"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["When you specify the objects to render in the ", {"text": ["UV render objects"], "type": "ui"}, ", you can optionally render the appearance of one object into the UV space of another object. This is useful for baking the look of high-res geometry and complex shaders, and then applying them to a much lower-resolution object."]}, {"indent": 0, "type": "para", "text": ["By default, baking will use the surface normal of the lower-resolution object for projection. This may be undesired in areas where there are normal discontinuities. For such cases, you may optionally specify ", {"text": ["UV cage object"], "type": "ui"}, " which is a dupicate of of ", {"text": ["UV object"], "type": "ui"}, " whose vertices are manually pushed out slightly. The ", {"text": ["UV cage object"], "type": "ui"}, " will then be used to map points toward ", {"text": ["UV object"], "type": "ui"}, " as the new projection direction."]}], "indent": 0, "level": 2, "text": ["Baking high-res object onto low-res object"], "container": true, "type": "h", "id": "xfer"}, {"body": [{"indent": 0, "type": "para", "text": ["You can use the ", {"text": ["UV render objects"], "type": "ui"}, " parameter to specify multiple objects to render. You can also use wildcards in the ", {"text": ["UV render objects"], "type": "ui"}, " sub-parameters to match multiple objects in one go."]}, {"indent": 0, "type": "para", "text": ["When you have one pattern in the ", {"text": ["UV object"], "type": "ui"}, " path, and a corresponding ", {"text": ["*"], "type": "code"}, " wildcard in the ", {"text": ["Output picture"], "type": "ui"}, " filename, the node will replace the ", {"text": ["*"], "type": "code"}, " in the filename with the match from the object path."]}, {"indent": 0, "type": "para", "text": ["For example, if the ", {"text": ["UV object"], "type": "ui"}, " path is ", {"text": ["/obj/*"], "type": "code"}, ", and the ", {"text": ["Output picture"], "type": "ui"}, " filename is ", {"text": ["$HIP/textures/*.rat"], "type": "code"}, ", then the node will render ", {"text": ["/obj/apple"], "type": "code"}, " as ", {"text": ["$HIP/textures/apple.rat"], "type": "code"}, ", ", {"text": ["/obj/bear"], "type": "code"}, " as ", {"text": ["$HIP/textures/bear.rat"], "type": "code"}, ", and so on."]}, {"indent": 0, "type": "para", "text": ["Note that the pattern in the ", {"text": ["UV object"], "type": "ui"}, " path can be something other than a ", {"text": ["*"], "type": "code"}, ". For example, if you have the objects ", {"text": ["/obj/ball1"], "type": "code"}, ", ", {"text": ["/obj/ball2"], "type": "code"}, ", and ", {"text": ["/obj/ball3"], "type": "code"}, ", you could use a path of ", {"text": ["/obj/ball[1-3]"], "type": "code"}, " and an output filename like ", {"text": ["$HIP/textures/*.rat"], "type": "code"}, "."]}], "indent": 0, "level": 2, "text": ["Object pattern matching"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": ["As with a regular render, you can output multiple image planes as textures. For example shading position, direct lighting, indirect lighting, and so on."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Mantra unwraps the model using a lens shader (see ", {"text": ["$HH/CVex/uvlens.vfl"], "type": "code"}, "). Mantra only supports lens shaders in ray-tracing and PBR ray-tracing."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["The lens shader raises the \"camera\" very slightly above the surface, to account for precision errors in calculating the surface position. This means it\u2019s very important to have correct surface normals on the model. If the model\u2019s normals are reversed for some reason, you can un-reverse them on this node using the ", {"text": ["Reverse normals"], "type": "ui"}, " parameter."]}, {"indent": 0, "blevel": 3, "type": "bullet", "text": ["The ", {"text": "", "value": "/vex/functions/uvunwrap", "fallback_text": "uvunwrap()", "fullpath": "/vex/functions/uvunwrap", "scheme": "Vex", "type": "link"}, " function the lens shader uses correctly accounts for subdivided surfaces and displacement shaders when calculating the surface positions."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["When ", {"text": ["Extract Format"], "type": "ui"}, " does not support floating point data (such as ", {"text": ["TGA"], "type": "code"}, ", ", {"text": ["PNG"], "type": "code"}, " or ", {"text": ["JPG"], "type": "code"}, "), the output values of ", {"text": ["Tangent-Space Normal (Nt)"], "type": "code"}, " and ", {"text": ["Shading Normal (N)"], "type": "code"}, " planes will be automatically remapped from -1~1 to 0~1."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Writing out UDIM tiles for ", {"text": ["Extra Image Planes"], "type": "ui"}, " with ", {"text": ["Different File"], "type": "ui"}, " option is currently unsupported."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Tips and notes"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["This is a version of the regular ", {"text": ["Mantra render node"], "fullpath": "/nodes/out/ifd", "scheme": "Node", "type": "link", "value": "/nodes/out/ifd"}, " which is configured with parameters to allow for easy baking of texture maps for objects. See the ", {"text": ["help for the render node"], "fullpath": "/nodes/out/ifd", "scheme": "Node", "type": "link", "value": "/nodes/out/ifd"}, " for more general help."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Choose \"UDIM\" to generate regular UV images, or \"Ptex\" to generate Ptex images."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Texture Format"]}, {"body": [{"indent": 4, "type": "para", "text": ["The size of the output texture image. This is ignored for Ptex textures. This can be from ", {"text": ["128"], "type": "code"}, " to ", {"text": ["2048"], "type": "code"}, " pixels."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Resolution"]}, {"body": [{"indent": 4, "type": "para", "text": ["For Ptex, the texture size to use for the smallest faces in each object, from ", {"text": ["4"], "type": "code"}, " to ", {"text": ["1024"], "type": "code"}, " pixels."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Minimum Map Resolution"]}, {"body": [{"indent": 4, "type": "para", "text": ["For Ptex, the maximum possible texture size to use, from ", {"text": ["4"], "type": "code"}, " to ", {"text": ["1024"], "type": "code"}, " pixels. This is a clamp on the per-face value calculated by multiplying the ", {"text": ["Minimum map resolution"], "type": "ui"}, " by the ", {"text": ["Map resolution scale"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Maximum Map Resolution"]}, {"body": [{"indent": 4, "type": "para", "text": ["For Ptex, this node calculates the size of each texture by scaling the ", {"text": ["Minimum map resolution"], "type": "ui"}, " based on the relative size of each face. The smallest faces will get the ", {"text": ["Minimum map resolution"], "type": "ui"}, ". With a scale of ", {"text": ["1.0"], "type": "code"}, ", faces 2\u00d7 larger than the smallest will get 2\u00d7 larger textures. If you set the scale to ", {"text": ["0.0"], "type": "code"}, ", ", {"text": ["all"], "type": "em"}, " faces will get the minimum resolution."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Map Resolution Scale"]}, {"body": [{"indent": 4, "type": "para", "text": ["For each object you want to render, click the ", {"text": "", "fullpath": "/nodes/out/BUTTONS/add", "scheme": "Smallicon", "type": "link", "value": "BUTTONS/add"}, " Add button and enter the path of the object in ", {"text": ["UV Object"], "type": "ui"}, ", and the texture filename in ", {"text": ["Output picture"], "type": "ui"}, ". You can do ", {"fragment": "#patterns", "text": ["simple pattern expansion"], "value": "#patterns", "fullpath": "/nodes/out/baketexture#patterns", "scheme": null, "type": "link"}, " in the path and filename."]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["To take the rendered appearance of a high resolution object and bake it into the texture space of the ", {"text": ["UV object"], "type": "ui"}, ", enter the path of the ", {"text": ["High res object"], "type": "ui"}, "."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["To bake using the projection direction from a cage object, enter the path of ", {"text": ["UV cage object"], "type": "ui"}, ". "]}], "container": true, "type": "bullet_group"}, {"indent": 4, "type": "para", "text": ["The output picture field accepts a few special codes:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["When ", {"text": ["Texture unwrapping method"], "type": "ui"}, " is \"UDIM\", you can use ", {"text": ["%(UDIM)d"], "type": "code"}, " in the filename, and the node will replace it with the UDIM index to render out multiple files."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["If you enter ", {"text": ["%(CHANNEL)s"], "type": "code"}, " as part of the filename, the node will replace it with the channel name."]}], "container": true, "type": "bullet_group"}, {"body": [{"body": [{"indent": 8, "type": "para", "text": [{"text": ["Output picture"], "type": "ui"}, " must be a floating point image format that supports multi-channel images for ", {"text": ["UDIM Post Process"], "type": "ui"}, " and ", {"text": ["Extract image planes"], "type": "ui"}, " to work correctly. It is strongly recommended to leave it in .rat format, and use ", {"text": ["Extract image planes"], "type": "ui"}, " to extract the channels into a different format."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["UV Render Objects"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"indent": 0, "type": "para", "text": ["You can use the controls on the ", {"text": ["Output"], "type": "ui"}, " tab to rename the channels in the output filenames."]}, {"body": [{"body": [{"type": "para", "indent": 4, "text": ["When baking, instead of writing shading position ", {"text": ["P"], "type": "code"}, " raw, it will be normalized to 0~1 based on bounding cube of the UV Object."]}], "indent": 0, "text": ["Fit P To Object Bounding Box"], "role": "item", "attrs": {"ifdprop": "renderer:bake_normalizep", "hprop": "vm_bake_normalizep"}, "type": "parameters_item", "id": "vm_bake_normalizep"}, {"body": [{"indent": 4, "type": "para", "text": ["When enabled, image planes contained in the output image will be extracted to separate files. The files will be saved alongside the output image, in the format: <basename>.<plane name>.<extension>."]}], "indent": 0, "text": ["Extract image planes"], "role": "item", "attrs": {"ifdprop": "renderer:extractimageplanes", "hprop": "vm_extractimageplanes"}, "type": "parameters_item", "id": "vm_extractimageplanes"}, {"body": [], "indent": 0, "text": ["Shading tangent-space normal (Nt)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_Nt"}, "type": "parameters_item", "id": "vm_quickplane_Nt"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. Stores the magnitude between the high-res and low-res objects."]}], "indent": 0, "text": ["Displacement (Ds)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Ds"}, "type": "parameters_item", "id": "vm_quickplane_Ds"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. Stores the deltas between the high-res and low-res objects."]}], "indent": 0, "text": ["Vector Displacement (Vd)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Vd"}, "type": "parameters_item", "id": "vm_quickplane_Vd"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. Stores the deltas between the high-res and low-res objects in the low-res object\u2019s tangent-space."]}], "indent": 0, "text": ["Tangent-Space Vector Displacement (Vdt)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Vdt"}, "type": "parameters_item", "id": "vm_quickplane_Vdt"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. The occlusion at the shading position."]}], "indent": 0, "text": ["Occlusion (Oc)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Oc"}, "type": "parameters_item", "id": "vm_quickplane_Oc"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. The occlusion along the inverted normal at the shading position.  This produces \"relief\" shading."]}], "indent": 0, "text": ["Cavity (Cv)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Cv"}, "type": "parameters_item", "id": "vm_quickplane_Cv"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. The thickness at the shading position."]}], "indent": 0, "text": ["Thickness (Th)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Th"}, "type": "parameters_item", "id": "vm_quickplane_Th"}, {"body": [{"indent": 4, "type": "para", "text": ["Used when baking textures. The curvature at the shading position."]}], "indent": 0, "text": ["Curvature (Cu)"], "role": "item", "attrs": {"hprop": "vm_quickplane_Cu"}, "type": "parameters_item", "id": "vm_quickplane_Cu"}, {"body": [], "indent": 0, "text": ["Shading position (P)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_P"}, "type": "parameters_item", "id": "vm_quickplane_P"}, {"body": [], "indent": 0, "text": ["Shading normal (N)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_N"}, "type": "parameters_item", "id": "vm_quickplane_N"}, {"body": [], "indent": 0, "text": ["Surface Unlit Base Color (basecolor)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_basecolor"}, "type": "parameters_item", "id": "vm_quickplane_basecolor"}, {"body": [], "indent": 0, "text": ["Surface Unlit Diffuse Color (diffcolor)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_diffcolor"}, "type": "parameters_item", "id": "vm_quickplane_diffcolor"}, {"body": [], "indent": 0, "text": ["Surface Unlit Specular Color (speccolor)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_speccolor"}, "type": "parameters_item", "id": "vm_quickplane_speccolor"}, {"body": [], "indent": 0, "text": ["Surface Emission Color (emitcolor)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_emitcolor"}, "type": "parameters_item", "id": "vm_quickplane_emitcolor"}, {"body": [], "indent": 0, "text": ["Surface SSS color (ssscolor)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_ssscolor"}, "type": "parameters_item", "id": "vm_quickplane_ssscolor"}, {"body": [], "indent": 0, "text": ["Surface Metallic (metallic)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_metallic"}, "type": "parameters_item", "id": "vm_quickplane_metallic"}, {"body": [], "indent": 0, "text": ["Surface Roughness (specrough)"], "role": "item", "attrs": {"status": "nd", "hprop": "vm_quickplane_specrough"}, "type": "parameters_item", "id": "vm_quickplane_specrough"}, {"body": [{"indent": 4, "type": "para", "text": ["These controls let you output VEX variables as auxiliary image planes, either as extra planes in the output file or extra files."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["As of Houdini 9.1, each channel can now be written out to a different file. This lets you work with OpenEXR programs that don\u2019t support multiple channels in a single ", {"text": [".exr"], "type": "code"}, " image."]}, {"indent": 8, "type": "para", "text": ["You can also do fancy stuff like send one channel to the ", {"text": ["md"], "type": "code"}, " device (a non-interactive MPlay window), or split your image into multiple ", {"text": [".pic"], "type": "code"}, " files with a handful of ", {"text": [".tif"], "type": "code"}, " files thrown in. But if the primary image is ", {"text": ["ip"], "type": "code"}, ", all planes go to ", {"text": ["ip"], "type": "code"}, "."]}], "indent": 4, "role": "item", "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"indent": 4, "type": "para", "text": ["The Channel Name parameter lets you give the channel in the output file a different name than the default (the name of the VEX variable). For example, you want to send out the Of variable. If the Channel Name is left blank, the plane name in the ", {"text": [".pic"], "type": "code"}, " file will be ", {"text": ["Of"], "type": "code"}, ". If you set Channel Name to ", {"text": ["Opacity"], "type": "code"}, ", the plane in the ", {"text": [".pic"], "type": "code"}, " file will be called ", {"text": ["Opacity"], "type": "code"}, "."]}], "indent": 0, "text": ["Extra image planes"], "role": "item", "attrs": {"hprop": "vm_numaux"}, "type": "parameters_item", "id": "vm_numaux"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Main"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["The controls on this tab let you optionally remap channel names to new strings in the output filenames. Turning on export of a channel on the ", {"text": ["Main"], "type": "ui"}, " sub-tab enables the corresponding renaming field on this sub-tab."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["When extracting images for baking, this is the separator string that\u2019s inserted between the filename and the channel name.  For with a separator of ", {"text": ["."], "type": "code"}, ", the extracted image might be ", {"text": ["texture.Nt.png"], "type": "code"}, " instead of ", {"text": ["texture_Nt.png"], "type": "code"}, "."]}], "indent": 0, "text": ["Name Separator"], "role": "item", "attrs": {"ifdprop": "renderer:extractseparator", "hprop": "vm_extractseparator"}, "type": "parameters_item", "id": "vm_extractseparator"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Output"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Images"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Disables all lighting on primary image plane in order to make baking faster."]}], "indent": 0, "text": ["Disable Lighting/Emission"], "role": "item", "attrs": {"hprop": "vm_bake_skipcf"}, "type": "parameters_item", "id": "vm_bake_skipcf"}, {"body": [{"indent": 4, "type": "para", "text": ["Add baking related shader exports to layers structs, so they can be mixed by layer compositing operations and finally exported."]}], "indent": 0, "text": ["Add Baking Exports to Shader Layers"], "role": "item", "attrs": {"hprop": "vm_bake_layerexport"}, "type": "parameters_item", "id": "vm_bake_layerexport"}, {"body": [{"indent": 4, "type": "para", "text": ["Number of samples to use for raytraced shading (eg. Occlusion, Cavity, Thickness). Increasing the number of samples will reduce noise in the shading."]}], "indent": 0, "text": ["Baking samples"], "role": "item", "attrs": {"hprop": "vm_bake_samples"}, "type": "parameters_item", "id": "vm_bake_samples"}, {"body": [{"indent": 4, "type": "para", "text": ["Use Mikkelsen\u2019s Tangent Space for baking tangent space normals (", {"text": ["Nt"], "type": "code"}, "). The basis is computed per-fragment (Unreal Engine compatible). Use a ", {"text": ["Divide SOP"], "fullpath": "/nodes/sop/divide", "scheme": "Node", "type": "link", "value": "/nodes/sop/divide"}, " to convert the UV Object into triangle mesh before baking because other applications may interpolate tangents across quads differently."]}], "indent": 0, "text": ["Use MikkT Tangent Space"], "role": "item", "attrs": {"ifdprop": "renderer:bake_usemikkt", "hprop": "vm_bake_usemikkt"}, "type": "parameters_item", "id": "vm_bake_usemikkt"}, {"body": [{"indent": 4, "type": "para", "text": ["Toggles flipping of the normal\u2019s X axis. Various packages may expect normal maps in different spaces. The flip parameters allow you to match these various spaces."]}], "indent": 0, "text": ["Tangent Normal Flip X"], "role": "item", "attrs": {"hprop": "vm_bake_tangentnormalflipx"}, "type": "parameters_item", "id": "vm_bake_tangentnormalflipx"}, {"body": [{"indent": 4, "type": "para", "text": ["Toggles flipping of the normal\u2019s Y axis. Various packages may expect normal maps in different spaces. The flip parameters allow you to match these various spaces."]}], "indent": 0, "text": ["Tangent Normal Flip Y"], "role": "item", "attrs": {"hprop": "vm_bake_tangentnormalflipy"}, "type": "parameters_item", "id": "vm_bake_tangentnormalflipy"}, {"body": [], "indent": 0, "text": ["Include Displacement in Tangent Normal"], "role": "item", "attrs": {"hprop": "vm_bake_tangentnormalincludedisp"}, "type": "parameters_item", "id": "vm_bake_tangentnormalincludedisp"}, {"body": [{"indent": 4, "type": "para", "text": ["This acts as a contrast control over the occlusion shading, with values higher and lower than ", {"text": ["0.5"], "type": "code"}, " resulting in more and less contrast."]}], "indent": 0, "text": ["Occlusion Bias"], "role": "item", "attrs": {"hprop": "vm_bake_occlusionbias"}, "type": "parameters_item", "id": "vm_bake_occlusionbias"}, {"body": [{"indent": 4, "type": "para", "text": ["Controls the distance within which features will influence the shading."]}], "indent": 0, "text": ["Cavity Distance"], "role": "item", "attrs": {"hprop": "vm_bake_cavitydistance"}, "type": "parameters_item", "id": "vm_bake_cavitydistance"}, {"body": [{"indent": 4, "type": "para", "text": ["This acts as a contrast control over the cavity occlusion shading, with values higher and lower than ", {"text": ["0.5"], "type": "code"}, " resulting in more and less contrast."]}], "indent": 0, "text": ["Cavity Bias"], "role": "item", "attrs": {"hprop": "vm_bake_cavitybias"}, "type": "parameters_item", "id": "vm_bake_cavitybias"}, {"body": [{"indent": 4, "type": "para", "text": ["This is a course but fast approximation for measuring curvature. When off (the default), the renderer measures curvature using local topology. Turning this on measures curvature by casting occlusion rays. The number of occlusion rays is controlled by ", {"text": ["Baking Samples"], "type": "ui"}, " parameter."]}], "indent": 0, "text": ["Occlusion-based Curvature"], "role": "item", "attrs": {"hprop": "vm_bake_curvatureocc"}, "type": "parameters_item", "id": "vm_bake_curvatureocc"}, {"body": [{"indent": 4, "type": "para", "text": ["Maximum occlusion ray distance to use when ", {"text": ["Occlusion-based Curvature"], "type": "ui"}, " is on."]}], "indent": 0, "text": ["Curvature Ray Distance"], "role": "item", "attrs": {"hprop": "vm_bake_curvaturesdist"}, "type": "parameters_item", "id": "vm_bake_curvaturesdist"}, {"body": [{"indent": 4, "type": "para", "text": ["Multiplies the output curvature value. If you are seeing any curvature shading you should increase this value until the gradient is visible."]}], "indent": 0, "text": ["Curvature Scale"], "role": "item", "attrs": {"hprop": "vm_bake_curvaturescale"}, "type": "parameters_item", "id": "vm_bake_curvaturescale"}, {"body": [{"indent": 4, "type": "para", "text": ["This acts as a contrast control over the curvature\u2019s shading, with values higher and lower than ", {"text": ["0.5"], "type": "code"}, " resulting in more and less contrast."]}], "indent": 0, "text": ["Curvature Bias"], "role": "item", "attrs": {"hprop": "vm_bake_curvaturebias"}, "type": "parameters_item", "id": "vm_bake_curvaturebias"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Baking"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Selects the method used to unwrap from the 'UV Object'."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Maps the UVs to their locations on the surface of the object."]}], "indent": 4, "type": "dt", "text": ["UV To Surface"]}, {"body": [{"indent": 8, "type": "para", "text": ["Uses raytracing to find the surface closest to the ", {"text": ["UV Object"], "type": "ui"}, "."]}], "indent": 4, "type": "dt", "text": ["Trace Closest Surface"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Unwrap Method"], "role": "item", "attrs": {"hprop": "vm_uv_unwrap_method"}, "type": "parameters_item", "id": "vm_uv_unwrap_method"}, {"body": [{"indent": 4, "type": "para", "text": ["Determines how much to offset the position of the ray from the surface of the object along the normal vector. This value should be increased proportional to the displacement in a displacement shader (if there is one) in order to ensure that the ray hits the surface. The\n    bias is used solely for camera rays."]}], "indent": 0, "text": ["Ray Bias"], "role": "item", "attrs": {"hprop": "vm_uv_ray_bias"}, "type": "parameters_item", "id": "vm_uv_ray_bias"}, {"body": [{"indent": 4, "type": "para", "text": ["If ", {"text": ["vm_uv_unwrap_method"], "type": "code"}, " is set to ", {"text": ["Trace Closest Surface"], "type": "code"}, " this parameter controls the maximum distance to trace for nearby surfaces. Useful for limiting the areas of the scene that will be baked onto the low-res object."]}], "indent": 0, "text": ["Ray Max Distance"], "role": "item", "attrs": {"hprop": "vm_uv_ray_maxdist"}, "type": "parameters_item", "id": "vm_uv_ray_maxdist"}, {"body": [{"indent": 4, "type": "para", "text": ["When texture baking, this will reverse normals on the geometry.  This\n    determines the orientation of the surface for the baking lens shader (i.e.\n    shade the inside or outside of the surface)."]}], "indent": 0, "text": ["Reverse Normals"], "role": "item", "attrs": {"hprop": "vm_uv_flip_normal"}, "type": "parameters_item", "id": "vm_uv_flip_normal"}, {"body": [{"indent": 4, "type": "para", "text": ["When baking to a UDIM image, this option determines what type of post-processing is applied to the final image.  The choices are  ", {"text": ["No Post Processing"], "type": "ui"}, ", ", {"text": ["Border Expansion"], "type": "ui"}, ", ", {"text": ["Fill Background With Average Color"], "type": "ui"}, ", and ", {"text": ["Diffuse Fill"], "type": "ui"}, "."]}, {"body": [{"body": [{"indent": 12, "type": "para", "text": ["Currently, this is only supported when rendering to disk (not to flipbooks)"]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "text": ["UDIM Post Process"], "role": "item", "attrs": {"ifdprop": "renderer:uvpostprocess", "hprop": "vm_uvpostprocess"}, "type": "parameters_item", "id": "vm_uvpostprocess"}, {"body": [{"indent": 4, "type": "para", "text": ["When baking to a UDIM image and performing island border expansion, this\n    parameter indicates by how many pixels each island should be enlarged."]}], "indent": 0, "text": ["UV Additional Pixels at Border"], "role": "item", "attrs": {"ifdprop": "renderer:uvborderpixels", "hprop": "vm_uvborderpixels"}, "type": "parameters_item", "id": "vm_uvborderpixels"}, {"body": [{"indent": 4, "type": "para", "text": ["When baking to a Ptex image, this option determines the orientation of face ids for subfaces when splitting non-quad faces.  The default is to order the sub-faces counterclockwise.  However, some software expects to have the faces ordered clockwise."]}], "indent": 0, "text": ["Orient Ptex Subfaces Clockwise"], "role": "item", "attrs": {"ifdprop": "renderer:ptexwraporient", "hprop": "vm_ptexwraporient"}, "type": "parameters_item", "id": "vm_ptexwraporient"}, {"body": [{"indent": 4, "type": "para", "text": ["This parameter controls the light components excluded during bake renders. When baking it is common to render only view-independent components such as \"diffuse\". The default value of ", {"text": ["-diffuse & -volume"], "type": "code"}, " will only render diffuse and volume light paths."]}], "indent": 0, "text": ["Exclude Light Paths"], "role": "item", "attrs": {"hprop": "vm_uvlightpaths"}, "type": "parameters_item", "id": "vm_uvlightpaths"}, {"body": [{"indent": 4, "type": "para", "text": ["When baking to a Ptex image, mantra will look for primitive-level scalar attribute of this name to scale tile resolution of current face. Note that the scaled resolution is still clamped by Minimum and Maximum resolutions."]}], "indent": 0, "text": ["Ptex Scale Prim Attribute"], "role": "item", "attrs": {"ifdprop": "renderer:ptexscaleattr", "hprop": "vm_ptexscaleattr"}, "type": "parameters_item", "id": "vm_ptexscaleattr"}, {"body": [{"indent": 4, "type": "para", "text": ["If this is disabled, mantra will no longer measure relative size of faces compared with smallest faces in the model when baking to a Ptex image. The tile resolution of each face will simply be ", {"text": ["Minimum Ptex Map Resolution"], "type": "ui"}, " multiplied by ", {"text": ["Ptex Resolution Scale"], "type": "ui"}, " and primitive-level Ptex scale attribute (if one exists)."]}], "indent": 0, "text": ["Ptex Use Relative Scale"], "role": "item", "attrs": {"ifdprop": "renderer:ptexrelativescale", "hprop": "vm_ptexrelativescale"}, "type": "parameters_item", "id": "vm_ptexrelativescale"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Unwrapping"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Controls the number of primary rays Mantra will use to sample your scene per pixel. The two numbers represent an arrangement of samples in the X and Y axis and are generally the same number. However, for non-square pixels it may be necessary to use different values in X and Y. Multiplying these two values together will give you the number of primary rays per pixel."]}], "text": [{"text": "", "fullpath": "/images/render/mug/sampling_tab/PixelSampling.jpg", "scheme": "Image", "type": "link", "value": "/images/render/mug/sampling_tab/PixelSampling.jpg"}], "role": "item", "indent": 4, "type": "fig"}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 4, "type": "para", "text": ["Increasing Pixel Samples will result in a cleaner, higher quality image. However, since all other sampling values are multiplied by the number of Pixel Samples, they should only be increased when necessary. For more details on when to increase Pixel Samples, see the \u201cRemoving Noise\u201d section."]}], "indent": 0, "text": ["Pixel samples"], "role": "item", "attrs": {"ifdprop": "image:samples", "hprop": "vm_samples"}, "type": "parameters_item", "id": "vm_samples"}, {"body": [{"indent": 4, "type": "para", "text": ["When enabled, this parameter will cause Mantra to use ray variance antialiasing when determining the number of Secondary Rays to send for every Primary Ray."]}, {"indent": 4, "type": "para", "text": ["This means that rather than using a specific number of rays, Mantra will first send out a small number of rays and use this sample set to evaluate the Variance. Depending on the amount of various, Mantra will continue to send more rays up to the ", {"text": ["Max Ray Samples"], "type": "ui"}, " value. Ray Variance Antialiasing is useful for optimizing your render by sending more rays only in the areas they are needed."]}, {"indent": 4, "type": "para", "text": ["In cases where the minimum number of rays to remove noise is equal to the maximum number of rays, you may save a small amount of render time by disabling Ray Variance Antialiasing."]}], "indent": 0, "text": ["Ray variance anti-aliasing"], "role": "item", "attrs": {"ifdprop": "object:dorayvariance", "hprop": "vm_dorayvariance"}, "type": "parameters_item", "id": "vm_dorayvariance"}, {"body": [{"indent": 4, "type": "para", "text": ["This value is the ", {"text": ["minimum number of secondary rays"], "type": "strong"}, " to use for each BSDF type when generating an image. When ", {"text": ["Ray Variance anti-aliasing"], "type": "ui"}, " is disabled, this number represents the number of secondary rays to send regardless of the ", {"text": ["Noise Level"], "type": "ui"}, "."]}, {"indent": 4, "type": "para", "text": ["Remember, this number is multiplied by the current number of Pixel Samples ", {"text": ["and"], "type": "em"}, " the number of BSDF types on the material being evaluated."]}], "indent": 0, "text": ["Min Ray Samples"], "role": "item", "attrs": {"ifdprop": "object:minraysamples", "hprop": "vm_minraysamples"}, "type": "parameters_item", "id": "vm_minraysamples"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["How finely or coarsely a volume is sampled as a ray travels through it. Volumetric objects are made up of 3d structures called Voxels, the value of this parameter represents the number of voxels a ray will travel through before performing another sample."]}], "text": [{"text": "", "fullpath": "/images/render/mug/sampling_tab/VolumeQuality.jpg", "scheme": "Image", "type": "link", "value": "/images/render/mug/sampling_tab/VolumeQuality.jpg"}], "role": "item", "indent": 4, "type": "fig"}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 4, "type": "para", "text": ["The default value is ", {"text": ["0.25"], "type": "code"}, ", which means that every one of every four voxels will be sampled. A value of ", {"text": ["1"], "type": "code"}, " would mean that all voxels are sampled and a value of 2 would mean that all voxels are sampled twice. This means that the volume step rate value behaves in a similar way to pixel samples, acting as a multiplier on the total number of samples for volumetric objects."]}, {"indent": 4, "type": "para", "text": ["For volumes that aren\u2019t voxel based, like CVEX procedural volumes, Mantra will divide the bounding box of the volume into roughly 100 \u201cvirtual\u201d voxels. In these cases, setting the Volume Step Rate correctly is essential to maintaining the correct level of detail."]}, {"indent": 4, "type": "para", "text": ["Keep in mind that increasing the volume step rate can dramatically increase render times, so it should only be adjusted when necessary. Also, while increasing the default from ", {"text": ["0.25"], "type": "code"}, " can reduce volumetric noise, increasing the value beyond ", {"text": ["1"], "type": "code"}, " will rarely see similar results."]}, {"indent": 4, "type": "para", "text": ["For more information about volume sampling, see ", {"text": ["sampling and noise"], "fullpath": "/render/sampling", "scheme": null, "type": "link", "value": "/render/sampling"}, "."]}], "indent": 0, "text": ["Volume step rate"], "role": "item", "attrs": {"ifdprop": "object:volumesteprate", "hprop": "vm_volumesteprate"}, "type": "parameters_item", "id": "vm_volumesteprate"}, {"body": [{"indent": 4, "type": "para", "text": ["A factor to proportionally decrease the volume step rate only for shadows, relative to the volume step rate. Smaller values will cause mantra to use a larger ray march step size for shadow rays than other shading rays.  A value of 1 will produce equal quality for shadow rays and shading rays."]}], "indent": 0, "text": ["Volume shadow step rate"], "role": "item", "attrs": {"ifdprop": "object:volumeshadowsteprate", "hprop": "vm_volumeshadowsteprate"}, "type": "parameters_item", "id": "vm_volumeshadowsteprate"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["The number of transparent samples to be shaded as a ray travels through translucent objects. Increasing this value will result in less noise in translucent objects and is generally less costly than increasing Pixel samples, Volume Step Rate, or Min and Max ray samples. Stochastic Sampling will not have any effect on noise from Indirect Sources however."]}], "text": [{"text": "", "fullpath": "/images/render/mug/sampling/VolumeSamplingStochastic.jpg", "scheme": "Image", "type": "link", "value": "/images/render/mug/sampling/VolumeSamplingStochastic.jpg"}], "role": "item", "indent": 4, "type": "fig"}], "container": true, "role": "item_group", "type": "fig_group"}, {"indent": 4, "type": "para", "text": ["This may make the image noisier than without stochastic transparency, so you may need to compensate by, for example, increasing the pixel samples. You should generally leave this option on."]}, {"indent": 4, "type": "para", "text": ["The renderer ignores this option for micropolygon rendering (except for secondary ray tracing) and for renders that only generate opacity (such as deep shadow maps). In those cases it is more efficient to composite all the transparent shading results."]}, {"indent": 4, "type": "para", "text": ["Added in Houdini 12."]}], "indent": 0, "text": ["Stochastic transparency"], "role": "item", "attrs": {"ifdprop": "image:transparent", "hprop": "vm_transparent"}, "type": "parameters_item", "id": "vm_transparent"}, {"body": [{"indent": 4, "type": "para", "text": ["The number of transparent samples to shade when ", {"fragment": "#vm_transparent", "text": ["Stochastic Transparency"], "value": "#vm_transparent", "fullpath": "/props/mantra#vm_transparent", "scheme": null, "type": "link"}, " is on. Higher values improve shading quality for volumes and transparent surfaces, but are slower to render."]}], "indent": 0, "text": ["Stochastic samples"], "role": "item", "attrs": {"ifdprop": "image:transparentsamples", "hprop": "vm_transparentsamples"}, "type": "parameters_item", "id": "vm_transparentsamples"}, {"body": [{"indent": 4, "type": "para", "text": ["Sampling generally occurs in random patterns which change on every frame of an animation. This can cause a distracting \u201cbuzz\u201d when there is a significant amount of noise in your images which can make evaluation of other aspects of the scene difficult. Enabling this parameter will \u201clock\u201d the sampling patterns so that the noise remains the same on every frame."]}, {"indent": 4, "type": "para", "text": ["Also, in some cases where the final rendered images will be sent through a post-render de- noise process, it can be useful to have the noise remain constant frame to frame. Consistent sampling patterns can help when analyzing the noise."]}, {"indent": 4, "type": "para", "text": ["It defaults to \u201coff\u201d because it is generally unacceptable to have a locked sampling pattern for final sequences."]}], "indent": 0, "text": ["Sample lock"], "role": "item", "attrs": {"ifdprop": "image:samplelock", "hprop": "vm_samplelock"}, "type": "parameters_item", "id": "vm_samplelock"}, {"body": [{"indent": 4, "type": "para", "text": ["Adjusting this parameter will cause the pixel sampling patterns used by Mantra to be regenerated in different configurations. By default, the patterns change on every frame, so manually changing this value is not necessary."]}], "indent": 0, "text": ["Random seed"], "role": "item", "attrs": {"ifdprop": "renderer:randomseed", "hprop": "vm_randomseed"}, "type": "parameters_item", "id": "vm_randomseed"}, {"body": [{"indent": 4, "type": "para", "text": ["This parameter is related to the motion blur parameters which are available only when Motion Blur is enabled. Disabling this option will cause motion blur to be removed from the final rendered image, however the blurred Position will still be calculated, allowing for custom motion vector image planes to be created. For more information, see ", {"text": ["motion blur"], "fullpath": "/render/blur", "scheme": null, "type": "link", "value": "/render/blur"}, "."]}], "indent": 0, "text": ["Allow image motion blur"], "role": "item", "attrs": {"ifdprop": "renderer:imageblur", "hprop": "vm_imageblur"}, "type": "parameters_item", "id": "vm_imageblur"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Sampling"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Rendering"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"type": "para", "indent": 0, "text": ["The parameters on this tab determine which objects and lights are included in the IFD."]}, {"type": "para", "indent": 0, "text": ["Mantra processes these parameters in the following order:"]}, {"body": [{"type": "ord", "blevel": 2, "indent": 0, "text": ["Candidate objects/lights are selected."]}, {"type": "ord", "blevel": 2, "indent": 0, "text": ["Forced objects/lights are added. "]}, {"type": "ord", "blevel": 2, "indent": 0, "text": ["Objects/Lights matching the exclusion parameter are removed."]}], "type": "ord_group", "container": true}, {"body": [{"body": [{"type": "para", "indent": 4, "text": ["The geometry objects in this parameter will be included in the IFD if their display flags are turned on and their display channel is enabled."]}], "role": "item", "text": ["Candidate Objects"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Objects in this parameter are added to the IFD regardless of the state of their display. Objects can only be added to the IFD once."]}], "role": "item", "text": ["Force Objects"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Objects forced to be output as matte objects."]}], "role": "item", "text": ["Forced Matte"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Objects forced to be output as phantom objects."]}], "role": "item", "text": ["Forced Phantom"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Objects in this parameter are excluded from the scene, regardless of whether they are selected in the ", {"text": ["Candidate Objects"], "type": "ui"}, " or ", {"text": ["Force Objects"], "type": "ui"}, "."]}], "role": "item", "text": ["Exclude Objects"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Only lights in this parameter will be included in the IFD. This includes shadow map generation and illumination. If this parameter is set, the candidate, forced, and exclusion parameters are ignored."]}, {"type": "para", "indent": 4, "text": ["Using this parameter in conjunction with the ", {"text": ["render_viewcamera"], "type": "code"}, " property provides a quick way of generating shadow maps for selected lights."]}], "role": "item", "text": ["Solo Light"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Each light in this parameter is added to the IFD if the dimmer channel of the light is not 0. The standard light sets the dimmer channel to 0 when the light is not enabled."]}], "role": "item", "text": ["Candidate Lights"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["The lights in this parameter are added to the IFD regardless of the value in their dimmer channels."]}], "role": "item", "text": ["Force Lights"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["These lights will be excluded from the scene, even if they are selected in ", {"text": ["Candidate Lights"], "type": "ui"}, " or Force Lights__."]}], "role": "item", "text": ["Exclude Lights"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["If there are no lights in the scene, a headlight is created by default. To disable, turn off this checkbox."]}], "role": "item", "text": ["Headlight Creation"], "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["The fog/atmosphere objects in this parameter are included in the IFD if their display flags are turned on and their display channel is enabled."]}], "role": "item", "text": ["Visible Fog"], "indent": 0, "type": "parameters_item"}], "role": "item_group", "container": true, "type": "parameters_item_group"}], "container": true, "level": 3, "text": ["Objects"], "indent": 0, "type": "h", "id": "objects_tab"}, {"body": [{"indent": 0, "type": "para", "text": ["Each script command refers to an hscript command which will be run, regardless of the expression language selected for the parameter. The resulting string will be run as an hscript command. It is possible to use the python, unix or source hscript commands to perform complex processing."]}, {"indent": 0, "type": "para", "text": ["The commands are always run when rendering occurs. The command checks the parameters of the output driver when it is rendering a range or sending output to a command."]}, {"indent": 0, "type": "para", "text": ["Before the render occurs, Houdini will automatically set the current hscript directory to point to the output driver."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["This command is run before any IFDs are generated. It is only run once per render."]}], "text": ["Pre-Render Script"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["This command is run before each IFD is generated."]}], "text": ["Pre-Frame Script"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["This command is run after each IFD is generated. Although the IFD may have been generated, this does not necessarily mean that mantra has finished rendering the image when this command is run."]}], "text": ["Post-Frame Script"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["This command is run one time, after all IFDs have been generated. Although the IFD may have been generated, this does not necessarily mean that mantra has finished rendering the image when this command is run."]}], "text": ["Post-Render Script"], "role": "item", "indent": 0, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "container": true, "level": 3, "text": ["Scripts"], "indent": 0, "type": "h", "id": "scripts_tab"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The command (i.e. mantra) where the IFD file is sent. This will be disabled if the IFD file is saved to disk."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The Mantra ROP will not automatically gzip based on the file extension of the ", {"text": [".ifd"], "type": "code"}, " file. The file ", {"text": [".ifd.gz"], "type": "code"}, " will contain uncompressed data. However, you can set your render command to something like ", {"text": ["gzip > foo$F4.ifd.gz"], "type": "code"}, " to compress the file."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "text": ["Command"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The location where the IFD file is saved to disk. You must turn on the Disk File checkbox to enable this parameter."]}], "text": ["Disk File"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["When sending the output to a command, Houdini will normally return control after it is finished writing the IFD. This allows the render process to complete in the background. Turning on this parameter will force Houdini to block until the mantra finishes rendering the frame."]}, {"indent": 4, "type": "para", "text": ["When rendering a frame range, this option is automatically turned on. However, the option is not automatically turned on when rendering in an hscript or python loop construct. Therefore caution must be used or it is possible to end up starting multiple background renders."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The rps and rkill hscript commands can be used to query or kill background renders. "]}, {"indent": 8, "type": "para", "text": ["See the ", {"fragment": "#trouble", "text": ["Troubleshooting"], "value": "#trouble", "fullpath": "/nodes/out/ifd#trouble", "scheme": null, "type": "link"}, " section for more information."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "text": ["Block Until Render Complete"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["If this option is turned on, POP and DOP simulations will be initialized before rendering."]}], "text": ["Initialize Simulation OPs"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Enabling this checkbox will cause the driver to show up in the viewport menu. By default, SOHO output drivers to not appear in the viewport menu."]}], "text": ["Show In Viewport"], "role": "item", "indent": 0, "type": "parameters_item"}, {"body": [{"type": "para", "indent": 4, "text": ["Saves binary geometry in the IFD. If this option is turned off, ASCII geometry is saved in the IFD. Binary is much more efficient. ASCII is readable."]}], "indent": 0, "text": ["Save Binary Geometry"], "role": "item", "attrs": {"hprop": "vm_binarygeometry"}, "type": "parameters_item", "id": "vm_binarygeometry"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "container": true, "level": 3, "text": ["Driver"], "indent": 0, "type": "h", "id": "driver_tab"}], "indent": 0, "level": 2, "text": ["Advanced"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Mantra"], "fullpath": "/nodes/out/ifd", "scheme": "Node", "type": "link", "value": "/nodes/out/ifd"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "title": ["Bake Texture"], "summary": ["Generates a texture map from one or more objects' rendered appearance."], "attrs": {"version": null, "namespace": null, "internal": "baketexture", "context": "out", "type": "node", "icon": "ROP/mantra"}, "included": ["/nodes/out/ifd", "/nodes/out/standard", "/props/_minmax_styles", "/props/mantra"], "type": "root"}