
# Known issues:

# Won't behave properly if the frame inc is a value other than '1', cannot render on 2's, 5's, 10's, etc.
# Issues with ffmpeg looking for missing frames, seems to just encode the first frame as the movie

# possible that the getSeqInfo() function may fail for super large image sequences
# this shouldn't be a problem for the length of typical shots

def mkdir_p(path):
    import errno    
    import os
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def saveArchive(backup_directory):
    # Save a backup of the current Houdini session
    import time
    import hou
    import os

    # Get the file path of the current Houdini session
    # (Equivalent to $HIP/$HIPNAME)
    original_file = hou.hipFile.path()
    # Where to put the archive file?
    archive_dir = backup_directory
    # What do we want to save the archive file as?
    archive_file = time.strftime("%Y.%m.%d_%H.%M.%S")+'__'+hou.hipFile.basename()
    # Make sure this is a string (I was getting errors if I didn't do this)
    archive_file = str(archive_file)
    archive_file = archive_dir + os.path.sep + archive_file

    if not os.path.exists( os.path.dirname(os.path.abspath(archive_file)) ):
        #os.makedirs( os.path.dirname(os.path.abspath(archive_file)), 777)
        mkdir_p( os.path.dirname(os.path.abspath(archive_file)) )

    # Save the archive file
    hou.hipFile.save(file_name=archive_file, save_to_recent_files=False)
    # Revert the name of the Houdini session to what it was prior to executing this function
    hou.hipFile.setName(original_file)
    # Return the name of the session to what it was originally
    return archive_file

# returns [base name, padding, filetype, number of files, first file, last file]
# http://www.chrisevans3d.com/pub_blog/dealing-with-file-sequences-in-python/
def getSeqInfo(file):
    import os, re, glob
    dir = os.path.dirname(file)
    file = os.path.basename(file)
    segNum = re.findall(r'\d+', file)[-1]
    numPad = len(segNum)
    baseName = file.split(segNum)[0]
    fileType = file.split('.')[-1]
    globString = baseName
    for i in range(0,numPad): globString += '?'
    # Careful with this slash direction and what OS you use
    theGlob = glob.glob(dir+'/'+globString+file.split(segNum)[1])
    #theGlob = glob.glob(dir+'\\'+globString+file.split(segNum)[1])
    numFrames = len(theGlob)
    firstFrame = theGlob[0]
    lastFrame = theGlob[-1]
    return [baseName, numPad, fileType, numFrames, firstFrame, lastFrame]


def rndr(render_node_path):
    import hou, os, re, glob
    import time
    # path to the output driver that will perform the rendering (example: '/out/mantra1')
    rop_node_path = render_node_path
    
    # Get the name of the render node type
    # the parm names that this script is looking for on the rop node might be named differently depending on which render engine is used
    rop_node_type = hou.node(rop_node_path).type().name()
    # Some possiblities might be:
    # 'Redshift_ROP'
    # 'ifd'
    # 'wren'
    # 'arnold'

    # Save a backup of the houdini scene
    if rop_node_type == 'Redshift_ROP':
        backup_file_path = saveArchive( os.path.dirname(os.path.abspath(hou.parm(rop_node_path + '/RS_outputFileNamePrefix').eval())) )
    elif rop_node_type == 'ifd':
        backup_file_path = saveArchive( os.path.dirname(os.path.abspath(hou.parm(rop_node_path + '/vm_picture').eval())) )
    else:
        print 'ERROR'

    # Do the rendering
    hou.node(rop_node_path).render()
    ###hou.hscript('opparm -c '+rop_node_path+' execute')
    
    # Initialize an empty list, will be used to store all images generated by the render
    img_seq = []

    # frange is assigned a tuple (3 item list) so we know the frame range that was rendered (start, end, inc)
    frange = hou.parmTuple(rop_node_path + '/f').eval()

    # https://stackoverflow.com/questions/4189766/range-with-step-of-type-float/4189798#4189798
    # Iterate thru the range of frames rendered and eval the frame filepath at that specific frame
    # Doing this to get a list of all files that should be generated by the render.
    for i in xrange( int(frange[0]), int(frange[1] + 1.0), int(frange[2]) ):
        # Eval the frame file path parameter at every frame that was rendered to get complete list of images generated
        if rop_node_type == 'Redshift_ROP':
            img_seq.append( os.path.abspath(hou.parm(rop_node_path + '/RS_outputFileNamePrefix').evalAtFrame(i)) )
        elif rop_node_type == 'ifd':
            img_seq.append( os.path.abspath(hou.parm(rop_node_path + '/vm_picture').evalAtFrame(i)) )
    
    # This loops thru each frame of the rendered img_seq
    # I was doing this to convert each frame to a .png, but it's possible ffmpeg can just directly encode .exr to a movie
    for img in img_seq:
        if os.path.isfile(img):
            base, ext = os.path.splitext(img)

            #print 'running "%s"' % str('icp %s %s' % (img, base+'.png'))
            # http://www.sidefx.com/docs/houdini/ref/utils/iconvert.html
            #os.system('icp %s %s' % (img, base+'.png'))

            # This convert command seems much faster than Houdini's icp command
            ###os.system('iconvert %s %s' % (img, base+'.png'))
            tmp_var = 50
            #print 'iconvert %s %s' % (img, base+'.png')
            #os.system('convert %s -colorspace RGB -colorspace RGB %s' % (img, base+'.png'))

            # Might want to clean up these temporary png files later on!!!

    # This should be the directory containing the rendered frames
    ffmpeg_input = os.path.abspath(os.path.join(img_seq[0], os.pardir))

    # append a path sep and the baseName of the first image of the frames rendered
    ffmpeg_input += os.path.sep + getSeqInfo(img_seq[0])[0]
    print '00  ' + ffmpeg_input
    
    
    # Kind of sloppy, need to clean up naming of vars as this is no longer a flbk script
    mov_output_path = ffmpeg_input
    print '01  ' + mov_output_path
    mov_output_path += time.strftime("%Y.%m.%d_%H.%M.%S")
    print '01  ' + mov_output_path
    # Make sure we don't already have a period at the end of the string (avoid filename..mov situation)
    if mov_output_path.endswith('.'):
        mov_output_path += 'mov'
    else:
        mov_output_path += '.mov'
    print '02  ' + mov_output_path
    # Not sure if it's always %04d, or maybe just %4d works? 
    # str(getSeqInfo(img_seq[0])[1]) is the numPad of the img_seq (zero padding length)
    ffmpeg_input += '%0' + str(getSeqInfo(img_seq[0])[1]) + 'd'

    # This appends the img_seq file extension
    ffmpeg_input += os.path.splitext(img_seq[0])[1]


    # Make me a .mov
    # https://stackoverflow.com/questions/14430593/encoding-a-readable-movie-by-quicktime-using-ffmpeg
    # ffmpeg -i /tmp/%04d.JPEG -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" -f mp4 -vcodec libx264 -pix_fmt yuv420p .v1.mp4
    # add -y to the command line after input file path to force overwriting if file exists
    # See link below for more info about adding metadata with ffmpeg
    # https://ubuntuforums.org/showthread.php?t=1193808
    # You can simply press enter where you want the newline as you are typing your command.

    convert2mov_command = 'ffmpeg'

    # I think starting with a linear image, we have to tell ffmpeg gamma 2.2 or else it will look too dark
    convert2mov_command+=' -gamma 2.2' # https://superuser.com/a/1139735

    convert2mov_command+=' -start_number '+str(int(frange[0])) # In case we aren't starting at frame 1, http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
    
    convert2mov_command+=' -i '+ffmpeg_input
    convert2mov_command+=' -y'
    convert2mov_command+=' -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2"'
    convert2mov_command+=' -f mp4 -vcodec libx264 -pix_fmt yuv420p'

    # http://ffmpeg.gusari.org/viewtopic.php?f=11&t=3032
    # by default ffmpeg outputs 25fps, change this with: -r 24
    convert2mov_command+=' -r '+str(hou.fps())

    # Set the Constant Rate Factor of the video
    # http://slhck.info/video/2017/02/24/crf-guide.html
    convert2mov_command+=' -crf 8'
    # Set the bitrate of the vide0
    # https://gist.github.com/ksharsha/b06d184391290bc3b87fdadadb73c5bc#file-ffmpeg-compress
    #convert2mov_command+=' -b:v 750k'
    convert2mov_command+=' -metadata title="'+hou.getenv('HIPNAME')+'"'
    convert2mov_command+=' -metadata comment="'+hou.hipFile.path()+'\n'+hou.getenv('USER')+'\n'+hou.applicationVersionString()+'\n'+hou.applicationPlatformInfo()+'"'

    convert2mov_command+=' '+mov_output_path
    
    print 'running "%s"' % convert2mov_command
    os.system(convert2mov_command)

